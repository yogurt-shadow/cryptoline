///////////////////////////////////////////////////////////////////////////////
version="iversion dmodideal.lib 4.1.2.0 Feb_2019 "; // $Id: 635e88d50668a6d4e42149f5c51a7d95fa729447 $
category="Noncommutative";
info="
LIBRARY: dmodideal.lib     Algorithms for Bernstein-Sato ideals of morphisms
AUTHORS: Robert Loew,     robert.loew at rwth-aachen.de
         Viktor Levandovskyy,     levandov at math.rwth-aachen.de
         Jorge Martin Morales,    jorge at unizar.es

OVERVIEW:
Let K be a field of characteristic 0. Given a polynomial ring
R = K[x_1,...,x_n] and a map, given by polynomials F_1,...,F_r from R,
one is interested in the R[1/(F_1*...*F_r)]-module of rank one, generated by
the symbol F^s=F_1^(s_1)*...*F_r^(s_r) for symbolic discrete variables s_1,...,s_r.
This module R[1/(F_1*...*F_r)]*F^s has a structure of a D(R)[s_1,...,s_r]-module, where D(R)
is an n-th Weyl algebra K<x_1,...,x_n,d_1,...,d_n | d_j x_j = x_j d_j +1> and
D(R)[s] := D(R) tensored with K[s]:=K[s_1,...,s_r] over K.
We often write just D for D(R) and D[s] for D(R)[s].

One is interested in the computation of the following data:
@*- Ann_{D[s]} F^s, the annihilator of F^s in D[s]; see annihilatorMultiFs
@*- Ann^{1}_{D[s]} F^s, the logarithmic annihilator of F^s in D[s]; see annfsLogIdeal
@*- several kinds of global Bernstein-Sato ideals in K[s],
     cf. (CU) and (Bud12); see BernsteinSatoIdeal and BSidealFromAnn
@*- Ann_{D} F^alpha for alpha from K^r, the annihilator of F^alpha in D; see annfalphaI
@*- sub- and over-ideals, bounding the Bernstein-Sato ideal; see BFBoundsBudur

REFERENCES:
(BM) the Ann F^s algorithm by Briancon and Maisonobe (Remarques sur
       l'ideal de Bernstein associe a des polynomes, preprint, 2002)@*
(LM08) V. Levandovskyy and J. Martin-Morales, ISSAC 2008@*
(CU) Castro and Ucha, On the computation of Bernstein-Sato ideals, JSC 2005@*
(SST) Saito, Sturmfels, Takayama 'Groebner Deformations of Hypergeometric
       Differential Equations', Springer, 2000@*
(Bud12) N. Budur, Bernstein-Sato ideals and local systems, Annales de
        l'Institut Fourier,  Volume 65 (2015) no. 2@*
(OT99) T. Oaku and N. Takayama, An algorithm for de Rham cohomology groups of
       the complement of an affine variety via D-module computation,
       Journal of Pure and Applied Algebra, 1999

PROCEDURES:
annfsLogIdeal(F);       compute the logarithmic annihilator Ann^(1) F^s in D
annihilatorMultiFs(F[,eng,us,ord]);    compute the annihilator Ann F^s in D
BSidealFromAnn(F, @R [,eng,met]);      compute several kinds of Bernstein-Sato ideals, given Ann F^s
BernsteinSatoIdeal(F [,eng,met,us]);   compute several kinds of Bernstein-Sato ideals, given only F
BFBoundsBudur(F,m);       compute upper and lower bounds of several kinds of Bernstein-Sato ideals with the method of (Bud12)
annfalphaI(f,alpha);       compute Ann F^alpha in D, where alpha is an ideal from the ground field
extractS(I,r);       give I as ideal in the commutative polynomial ring in the first r variables

SEE ALSO: dmod_lib, dmodapp_lib, dmodloc_lib, gmssing_lib, bfun_lib

KEYWORDS: D-module; Bernstein-Sato ideal; global Bernstein-Sato ideal;
D-module structure; left annihilator ideal;  Weyl algebra; logarithmic annihilator ideal
";

LIB "dmod.lib";
LIB "dmodloc.lib";
LIB "ncpreim.lib"; //for eliminateNC

/* older text by Robert: now merged with the description
Guide:
@* - Ann F^s=Ann F_1^(s_1)*...*F_r^(s_r) can be computed by annihilatorMultiFs
@* - the global Bernstein-Sato ideal can be computed by BernsteinSatoIdeal
@* - Ann F^alpha for alpha from K^r can be computed by annfalphaI
@* - if several Bernstein-Sato ideals of the same ideal need to be computed,
@*   it may be useful to apply annihilatorMultiFs once and afterwards use the
@*   result for several calls of BSidealFromAnn
@* - if the exact computation of the Bernstein-Sato ideal does not terminate,
@*   the use of BFBoundsBudur may be successful
*/

/* from dmodloc.lib */
static proc safeVarName (string s)
"
USAGE:    safeVarName(s);  s string
RETURN:   string, returns s if s is not the name of a par/var of basering
          and `@' + s otherwise
EXAMPLE:  example safeVarName; shows examples
"
{
  string S = "," + charstr(basering) + "," + varstr(basering) + ",";
  s = "," + s + ",";
  while (find(S,s) <> 0)
  {
    s[1] = "@";
    s = "," + s;
  }
  s = s[2..size(s)-1];
  return(s);
}
example
{
  "EXAMPLE:"; echo = 2;
  ring r = (0,a),(w,@w,x,y),dp;
  safeVarName("a");
  safeVarName("x");
  safeVarName("z");
  safeVarName("w");
}


static proc ksxD(ideal F)
"USAGE:  ksxD(F);  F an ideal, call from a polynomial ring
ASSUME: basering is a commutative polynomial ring in characteristic 0
RETURN:  ring
PURPOSE: returns the ring k[_s,_x,_D] needed for annfs etc.
"
{
  int ppl = printlevel-voice+2;
  def save = basering;
  int N = nvars(basering);
  //if F has some generators which are zero, int P = ncols(F);
  int P = size(F);
  if (P == 0)
  {
    ERROR("zero ideal in the input");
  }
  P = ncols(F);
  int Nnew = 2*N+P;
  int i,j;
  string s;
  list RL = ringlist(basering);
  list L, Lord;
  list tmp;
  intvec iv;
  L[1] = RL[1];  //char
  L[4] = RL[4];  //char, minpoly
  // construct list of varnames
  list Name  = RL[2];
  list RName;
  for (j=1; j<=P; j++)
  {
    RName[j] = safeVarName("s("+string(j)+")");
  }
  // now, create the names for new vars
  list DName;
  for(i=1; i<=N; i++)
  {
    DName[i] = safeVarName("D"+Name[i]);
  }
  list NName = RName + Name + DName;
  L[2]   = NName;
  // Name, Dname will be used further
  kill NName;
  // block ord (lp(P),dp);
  tmp[1] = "lp";  //string
  tmp[2] = intvec(1:P);  //intvec
  Lord[1] = tmp;
  // continue with dp 1,1,1,1...
  tmp[1] = "dp";  //string
  tmp[2]  = intvec(1:Nnew);
  Lord[2] = tmp;
  tmp[1]  = "C";
  tmp[2]  = intvec(0);
  Lord[3] = tmp;
  tmp     = 0;
  L[3]    = Lord;
  // we are done with the list
  def @R@ = ring(L);
  setring @R@;
  // add non-commutative relations
  matrix @D[Nnew][Nnew];
  for(i=1; i<=N; i++)
  {
    @D[P+i,P+N+i] = 1;
  }
  def @R = nc_algebra(1,@D);
  return(@R);
}
example
{
  "EXAMPLE:"; echo = 2;
  ring R = 0,(x,y),dp;
  ideal F = x,y,0,1;
  ksxD(F);
}


proc annfsLogIdeal(ideal F)
"USAGE:  annfsLogIdeal(F);  F an ideal
RETURN:  ring
PURPOSE: compute the logarithmic annihilator of F[1]^s(1)*...*F[P]^s(P)
ASSUME:  basering is a commutative polynomial ring in characteristic 0
NOTE:    activate the output ring with the @code{setring} command. In this ring,
         annfsLog is the logarithmic annihilator of F^s (no Groebner basis).
         If printlevel=1, progress debug messages will be printed,
         if printlevel>=2, all the debug messages will be printed.
EXAMPLE: example annfsLogIdeal; shows examples
"
{
  int ppl = printlevel-voice+2;
  dbprint(ppl,"// enter annfsLogIdeal");
  dbprint(ppl-1, F);
  if(!isCommutative()){
    ERROR("Expected commutative polynomial ring.");
  }
  def @R = ksxD(F);
  def save = basering;
  int N = nvars(basering);
  //if F has some generators which are zero, int P = ncols(I);
  int P = size(F);
  if (P < ncols(F))
  {
    ERROR("//One factor is 0.");
  }
  P = size(F);
  dbprint(ppl,"// adding syzygy-driven elements to the ideal");
  // -- form the extended Jacobian matrix; do the comps over K[x]
  module JC = module(transpose(jacob(F))); // NxP
  for (int j=1; j<=P; j++)
  {
    JC[j] = JC[j] + F[j]*gen(N+j);
  }
  dbprint(ppl,"// computing syzygies of the extended Jacobian matrix over K[_x]");
  dbprint(ppl-1, matrix(JC));
  matrix SJ = transpose(syz(transpose(JC)));
  dbprint(ppl,"// finished computing syzygies of the ext Jacobian matrix over K[_x]");
  dbprint(ppl-1, matrix(SJ));
  setring @R;
  // add generators: first N comps d_i, then P comps s_j
  matrix SJ = imap(save, SJ);
  poly pi;
  ideal annfsLog;
  for (int i=1; i<=nrows(SJ); i++)
  {
    pi = 0;
    for (j=1; j<=N; j++)
    {
      pi = pi + SJ[i,j]*var(P+N+j);
    }
    for (j=1; j<=P; j++)
    {
      pi = pi + SJ[i,N+j]*var(j);//=s(j)
    }
    dbprint(ppl-1, "// adding element:" + string(pi));
    annfsLog = annfsLog, pi;
  }
  annfsLog = simplify(annfsLog,2);
  // decision: GB is the wish of a user
  //annfsLog = std(annfsLog);
  export annfsLog;
  dbprint(ppl,"// exit annfsLogIdeal");
  return(@R);
}
example
{
  "EXAMPLE:"; echo = 2;
  ring R = 0,(x,y),dp;
  ideal F = x^3+y^4+x*y^3, x;
  def S1 = annfsLogIdeal(F);
  setring S1;
  annfsLog;
  setring R; // now compare with the full annihilator
  def S = annihilatorMultiFs(F);
  setring S;
  annFs;
  lead(groebner(imap(S1,annfsLog)));
  lead(groebner(annFs)); // and we see the difference
}


static proc annFsOrder(int order, int n, int r)
"USAGE:  annFsOrder(ord,n,r);  ord,n,r ints
RETURN:  list
PURPOSE: static procedure for annihilatorMultiFs
         computes the order used for the ring in annihilatorMultiFs
NOTE:    ord describes the desired order from the following choices:
          0 - 'dp'
          1 - elimination order for x, 'dp' in the parts
          2 - elimination order for s, 'dp' in the parts
          3 - elimination order for x and s, 'dp' in the parts
          4 - elimination order for x and D, 'dp' in the parts
              (used for the further work in the Bernstein-Sato ideal)
         n and r describe the number of components x_i/Dx_i and s_j
"
{
  list tmp = 0;
  list Lord = 0;
  int i;

  if(order == 0){
    Lord = list(list("dp",2*n+r));
  }

  if(order == 1){
    // block ord (dp(n),dp);
    tmp[1] = "dp";  //string
    tmp[2] = intvec(1:n);    //intvec
    Lord[1] = tmp;
    // continue with dp 1,1,1,1...
    tmp[1] = "dp";  //string
    tmp[2]  = intvec(1:(n+r));
    Lord[2] = tmp;
    tmp[1]  = "C";
    tmp[2]  = intvec(0);
    Lord[3] = tmp;
  }

  if(order == 2){
    // "block" order ((0,0,dp),
    //                (dp,0,0),
    //                (0,dp,0))
    tmp[1] = "M";  //string

    //first r lines of the matrix
    tmp[2] = intvec((0:2*n),(1:r));    //intvec
    for(i=1; i<r; i++){
      tmp[2] = intvec(tmp[2],(0:(2*n+r-i)),intvec(-1));
      if(i>1){
        tmp[2] = intvec(tmp[2],(0:(i-1)));
      }
    }
    //next n lines of the matrix
    tmp[2] = intvec(tmp[2],(1:n),(0:(n+r)));    //intvec
    for(i=1; i<n; i++){
      tmp[2] = intvec(tmp[2],(0:(n-i)),intvec(-1), intvec(0:(n+r+i-1)));
    }
    //last n lines of the matrix
    tmp[2] = intvec(tmp[2],(0:n),(1:n),(0:r));    //intvec
    for(i=1; i<n; i++){
      tmp[2] = intvec(tmp[2],(0:(2*n-i)),intvec(-1), intvec(0:(r+i-1)));
    }

    Lord[1] = tmp;
    tmp[1]  = "C";
    tmp[2]  = intvec(0);
    Lord[2] = tmp;
  }

  if(order == 3){
    // "block" order ((dp,0,0),
    //                (0,0,dp),
    //                (0,dp,0))
    tmp[1] = "M";  //string

    //first r lines of the matrix
    tmp[2] = intvec((1:n),(0:(n+r)));    //intvec
    for(i=1; i<n; i++){
      tmp[2] = intvec(tmp[2],(0:(n-i)),intvec(-1), intvec(0:(n+r+i-1)));
    }
    //next n lines of the matrix
    tmp[2] = intvec(tmp[2],(0:2*n),(1:r));    //intvec
    for(i=1; i<r; i++){
      tmp[2] = intvec(tmp[2],(0:(2*n+r-i)),intvec(-1));
      if(i>1){
        tmp[2] = intvec(tmp[2],(0:(i-1)));
      }
    }
    //last n lines of the matrix
    tmp[2] = intvec(tmp[2],(0:n),(1:n),(0:r));    //intvec
    for(i=1; i<n; i++){
      tmp[2] = intvec(tmp[2],(0:(2*n-i)),intvec(-1), intvec(0:(r+i-1)));
    }

    Lord[1] = tmp;
    tmp[1]  = "C";
    tmp[2]  = intvec(0);
    Lord[2] = tmp;
  }

  if(order == 4){
    // block ord (dp(2*n),dp);
    tmp[1] = "dp";  //string
    tmp[2] = intvec(1:(2*n));    //intvec
    Lord[1] = tmp;
    // continue with dp 1,1,1,1...
    tmp[1] = "dp";  //string
    tmp[2]  = intvec(1:r);
    Lord[2] = tmp;
    tmp[1]  = "C";
    tmp[2]  = intvec(0);
    Lord[3] = tmp;
  }

   return(Lord);
}


proc annihilatorMultiFs(ideal F, list #)
"USAGE:  annihilatorMultiFs(F [,eng,us,ord]);  F an ideal, eng, us, ord optional ints
RETURN:  ring
PURPOSE: compute Ann(F[1]^s(1)*...*F[P]^s(P))
         with the multivariate algorithm by Briancon and Maisonobe.
ASSUME:  basering is a commutative polynomial ring in characteristic 0
NOTE:    activate the output ring with the @code{setring} command. In this ring,
         the ideal annFs is the annihilator of F[1]^s_1*..*F[P]^s_p.
         If eng <>0, @code{std} is used for Groebner basis computations,
         otherwise, and by default @code{slimgb} is used.
         If us<>0, then syzygies-driven method is used additionally.
         If specified, ord describes the desired order from the following choices:
          0 - 'dp'
          1 - elimination order for x, 'dp' in the parts
          2 - elimination order for s, 'dp' in the parts
          3 - elimination order for x and s, 'dp' in the parts
          4 - elimination order for x and D, 'dp' in the parts
              (used for the further work in the Bernstein-Sato ideal)
         If printlevel=1, progress debug messages will be printed,
         if printlevel>=2, all the debug messages will be printed.
EXAMPLE: example annihilatorMultiFs; shows examples
"
{
  int ppl = printlevel - voice + 2;
  dbprint(ppl,"// enter annihilatorMultiFs");
  dbprint(ppl-1, F);
  dbprint(ppl-1, #);
  if(!isCommutative()){
    ERROR("Expected commutative polynomial ring.");
  }
  int eng = 0;
  int usesyz = 0;
  if ( size(#)>0 )
  {
    if ( typeof(#[1]) == "int" )
    {
      eng = int(#[1]);
    }
    if ( size(#)>1 )
    {
      if ( typeof(#[2]) == "int" )
      {
        usesyz = int(#[2]);
      }
    }
  }
  //  printf("plevel :%s, voice: %s",printlevel,voice);
  def save = basering;
  int N = nvars(basering);
  //if F has some generators which are zero, int P = ncols(I);
  int P = size(F);
  if (P < ncols(F))
  {
    ERROR("//One factor is 0.");
  }
  P = size(F);
  if (P == 0)
  {
    ERROR("zero ideal in the input");
  }
  int Nnew = 2*N+2*P;
  int i,j;
  string s;
  list RL = ringlist(basering);
  list L, Lord;
  list tmp;
  intvec iv;
  L[1] = RL[1];  //char
  L[4] = RL[4];  //char, minpoly
  // find new varnames
  list Name  = RL[2];
  list RName;
  for (j=1; j<=P; j++)
  {
    RName[j] = safeVarName("t("+string(j)+")");
    RName[j+P] = safeVarName("s("+string(j)+")");
  }
  list DName;
  for(i=1; i<=N; i++)
  {
    DName[i] = safeVarName("D"+Name[i]);  //concat
  }
  list NName = RName + Name + DName;
  L[2]   = NName;
  // Name, Dname will be used further
  kill NName;
  // block ord (lp(P),dp);
  tmp[1] = "lp";  //string
  tmp[2] = intvec(1:(2*P));  //intvec
  Lord[1] = tmp;
  // continue with dp 1,1,1,1...
  tmp[1] = "dp";  //string
  tmp[2]  = intvec(1:Nnew);
  Lord[2] = tmp;
  tmp[1]  = "C";
  tmp[2]  = intvec(0);
  Lord[3] = tmp;
  tmp     = 0;
  L[3]    = Lord;
  // we are done with the list
  def @R@ = ring(L);
  setring @R@;
  matrix @D[Nnew][Nnew];
  for (i=1; i<=P; i++)
  {
    @D[i,i+P] = var(i);//=t(i)
  }
  for(i=1; i<=N; i++)
  {
    @D[2*P+i,2*P+N+i] = 1;
  }
  // L[5] = matrix(UpOneMatrix(Nnew));
  // L[6] = @D;
  // @R is the non-commutative ring k<_t,_s,_x,_Dx>
  def @R = nc_algebra(1,@D);
  setring @R;
  kill @R@;
  dbprint(ppl,"// the ring @R(_t,_s,_x,_Dx) is ready");
  dbprint(ppl-1, @R);
  // create the ideal I which will become ann(F^s)
  ideal  F = imap(save,F);
  ideal I = var(1)*F[1]+var(P+1);//=t(1)*F[1]+s(1)
  for (j=2; j<=P; j++)
  {
    I = I, var(j)*F[j]+var(P+j);//=t(j)*F[j]+s(j)
  }
  poly p,q;
  for (i=1; i<=N; i++)
  {
    p=0;
    for (j=1; j<=P; j++)
    {
      q = var(j);//=t(j)
      q = diff(F[j],var(2*P+i))*q;
      p = p + q;
    }
    I = I, var(2*P+N+i) + p;
  }
  // -------- the ideal I is ready ----------
  if (usesyz)
  {
    //add Ann^1(F^s) to I
    setring save;
    def @R@ = annfsLogIdeal(F);
    setring @R;
    I = I, imap(@R@, annfsLog);
    kill @R@;
  }
  dbprint(ppl,"// starting the elimination of "+string(t(1..P))+" in @R");
  dbprint(ppl-1, I);
  ideal J = engine(I,eng);
  // K is already ann(F^s)
  ideal K = nselect(J,1..P);
  kill I,J;
  dbprint(ppl,"// all t(i) are eliminated");
  dbprint(ppl-1, K);  //K is without t(i)
  // ----------- the ring @R2 ------------
  // _x, _Dx,s;  elim.ord for _x,_Dx.
  // keep: N, i,j,s, tmp, RL
  setring save;
  Nnew = 2*N+P;
  kill Lord, tmp, iv, RName;
  list Lord, tmp;
  intvec iv;
  L[1] = RL[1];  //char
  L[4] = RL[4];  //char, minpoly
  // now, create the names for new var
  for (j=1; j<=P; j++)
  {
    tmp[j] = safeVarName("s("+string(j)+")");
  }
  list safeSName = tmp; //for later use
  // DName is defined earlier
  list NName = Name + DName + tmp;
  L[2] = NName;
  tmp = 0;
  if ( size(#)>2 ){
    L[3]  = annFsOrder(#[3],(Nnew-P) div 2,P);
  }
  else
  {
    L[3]  = annFsOrder(0,(Nnew-P) div 2,P);
  }
  // we are done with the list. Now add a Plural part
  def @R2@ = ring(L);
  setring @R2@;
  matrix @D[Nnew][Nnew];
  for (i=1; i<=N; i++)
  {
    @D[i,N+i]=1;
  }
  def @R2 = nc_algebra(1,@D);
  setring @R2;
  kill @R2@;
  dbprint(ppl,"// the ring @R2(_x,_Dx,_s) is ready");
  dbprint(ppl-1, @R2);
  ideal F = imap(save,F);
  ideal annFs = imap(@R,K);
  export annFs;

  dbprint(ppl,"// exit annihilatorMultiFs");
  return(@R2);
}
example
{
  "EXAMPLE:"; echo = 2;
  ring R = 0,(x,y),dp;
  ideal F = x^2-y,y;
  def S = annihilatorMultiFs(F,0,0,0);
  setring S;
  annFs;
  groebner(annFs);
}

proc BSidealFromAnn(ideal F, @R, list #)
"USAGE:  BSidealFromAnn(F, @R [,eng,met]);  F an ideal, @R a ring, eng, met optional ints
RETURN:  ring
PURPOSE: compute several kinds of Bernstein-Sato ideals, associated to
         f = F[1]*..*F[P], with the multivariate algorithm by Briancon and Maisonobe
         from ann(F^s) as input.
ASSUME:  basering is a commutative polynomial ring in characteristic 0
         @R is a ring as returned from annihilatorMultiFs.
NOTE:    activate the output ring with the @code{setring} command. In this ring,
         the ideal BS is a Bernstein-Sato ideal of a polynomial f = F[1]*..*F[P].
         If eng <>0, @code{std} is used for Groebner basis computations,
         otherwise, and by default @code{slimgb} is used.
         If met is of type int:
         if met <0, the B-Sigma ideal (cf. (CU)) is computed.
         If 0 < met < P, then the ideal B_met (cf. (CU)) is computed.
         If met is an intvec or a list of intvecs, Budurs generalized Bernstein-Sato ideal
         associated to met is computed.
         Otherwise, and by default, the ideal B (cf. (CU)) is computed.
         If met is of type intvec:
         Budurs generalized Bernstein-Sato ideal B^met_F is computed.
         If printlevel=1, progress debug messages will be printed,
         if printlevel>=2, all the debug messages will be printed.
EXAMPLE: example BSIdealFromAnn; shows examples
"
{
  int ppl = printlevel-voice+2;
  dbprint(ppl,"// enter BSidealFromAnn");
  dbprint(ppl-1, F);
  dbprint(ppl-1, @R);
  dbprint(ppl-1, #);
  if(!isCommutative()){
    ERROR("Expected commutative polynomial ring.");
  }
  if( typeof(@R) != "ring" )
  {
    ERROR("The second parameter should be of type ring.");
  }

  int met = 0;
  list metVecs;
  int eng = 0;
  if ( size(#) > 0 )
  {
    if ( typeof(#[1]) == "int" )
    {
      eng = int(#[1]);
    }
    if ( size(#) > 1 )
    {
      if ( typeof(#[2]) == "int" )
      {
        met = int(#[2]);
      }
      else{ if ( typeof(#[2]) == "intvec" )
      {
        metVecs = list(intvec(#[2]));
      }
      else{ if ( typeof(#[2]) == "list" )
      {
        metVecs = #[2];
      }
      else
      {
        ERROR("met does not have one of the allowed types.");
      }}}
    }
    else
    {
      met = 0;
    }
  }
  else
  {
    met = 0;
  }

  def save = basering;
  int N = nvars(basering);
  //if F has some generators which are zero, int P = ncols(I);
  int P = size(F);
  if (P < ncols(F))
  {
    ERROR("//One factor is 0.");
  }
  P = size(F);
  if (P == 0)
  {
    ERROR("zero ideal in the input");
  }

  int i,j;
  if(size(metVecs) != 0)
  {
    for(j=1; j<=size(metVecs); j++){
      if(ncols(F) != size(metVecs[j]))
      {
        ERROR("F and met do not have the same size.");
      }
      for(i=1; i<=size(metVecs[j]); i++){
        if(metVecs[j][i] < 0){
          ERROR("met has a negative entry.");
        }
      }
    }
  }

  list tmp;
  for (j=1; j<=P; j++)
  {
    tmp[j] = safeVarName("s("+string(j)+")");
  }
  list safeSName = tmp;

  setring @R;
  ideal K = annFs;
  ideal F = imap(save, F);

  // add the generator given by met to K=ann(F^s)
  if (met <0)
  {
  //K = K,F;     // to compute Bsigma (see "On the computation of Bernstein-Sato ideals"; Castro, Ucha)
    K = K,F;
    dbprint(ppl,"// computing the ideal B-Sigma from Castro-Ucha");
  }
  if( met > 0 && met <= ncols(F))
  {
    dbprint(ppl,"// computing the ideal B_" + string(met) + " from Castro-Ucha");
    K = K, F[met];
  }
  if ( ( met == 0 && size(metVecs) == 0) || (met > ncols(F) ) )
  {
    poly f=1;
    for (j=1; j<=P; j++)
    {
      f = f*F[j];
    }
    K = K,f;       // to compute B (Bernstein-Sato ideal)
    dbprint(ppl,"// computing the ideal B from Castro-Ucha");
  }

  if(size(metVecs) != 0)
  {
    poly f;
    for(j=1; j<=size(metVecs); j++){
      f = 1;
      for (i=1; i<=size(metVecs[j]); i++)
      {
        f = f*F[i]^metVecs[j][i];
      }
      K = K,f;
    }
    dbprint(ppl,"// computing the ideal B^(" + string(metVecs) + ") from Budur");
  }

  // eliminate everything except for the s(i)
  ideal K2 = eliminateNC(K,1..(nvars(basering)-P));
  kill K;
  dbprint(ppl-1, K2);
  // the ring @R3 and factorize
  ring @R3 = 0,s(1..P),dp;
  list RL = ringlist(@R3);
  RL[2] = safeSName;
  @R3 = ring(RL);
  setring(@R3);

  dbprint(ppl,"// the ring @R3(_s) is ready");
  ideal K3 = imap(@R,K2);
  ideal BS = K3;
  // create the ring @R4(_x,_Dx,_s) and put the result into it,
  setring save;
  ring @R4 = ksxD(F);
  setring @R4;

  dbprint(ppl,"// the ring @R4i(_x,_Dx,_s) is ready");
  dbprint(ppl-1, @R4);
  ideal K4 = imap(@R,K2);
  intvec saveopt=option(get);
  option(redSB);
  dbprint(ppl,"// -4-2- the final cosmetic std");
  K4 = engine(K4,eng);  //std does the job too
  // total cleanup
  kill @R;
  def BS = imap(@R3,BS);
  export BS;
  kill @R3;
  ideal LD = K4;
  export LD;
  option(set,saveopt);
  dbprint(ppl,"// exit BSidealFromAnn");
  return(@R4);
}
example
{
  "EXAMPLE:"; echo = 2;
  ring R = 0,(x,y),dp;
  ideal F = x+y,x-y,x;
  def @R = annihilatorMultiFs(F, 0, 0, 4);
  // first we compute the ideal B
  def @R2 = BSidealFromAnn(F, @R, 0, 0);
  setring @R2;
  BS;
  setring R;
  // secondly we compute the ideal B_1
  @R2 = BSidealFromAnn(F, @R, 0, 1);
  setring @R2;
  BS;
}

proc BernsteinSatoIdeal(ideal F, list #)
"USAGE:  BernsteinSatoIdeal(F [,eng,met,us]);  F an ideal, eng, us optional ints,
         met optional int or intvec
RETURN:  ring
PURPOSE: compute two kinds of Bernstein-Sato ideals, associated to
   f = F[1]*..*F[P], with the multivariate algorithm by Briancon and Maisonobe.
ASSUME:  basering is a commutative polynomial ring in characteristic 0
NOTE:    activate the output ring with the @code{setring} command. In this ring,@*
         - the ideal LD is the annihilator of F[1]^s_1*..*F[P]^s_p,@*
         - the list or ideal BS is a Bernstein-Sato ideal of a polynomial
           f = F[1]*..*F[P].
         If eng <>0, @code{std} is used for Groebner basis computations,
         otherwise, and by default @code{slimgb} is used.
         If met <0, the B-Sigma ideal (cf. Castro and Ucha, 'On the computation of Bernstein-Sato ideals', 2005) is computed.
         If 0 < met < P, then the ideal B_P (cf. the paper) is computed.
         If met is an intvec, Budurs generalized Bernstein-Sato ideal
         associated to met is computed.
         Otherwise, and by default, the ideal B (cf. the paper) is computed.
         If us<>0, then syzygies-driven method is used.
         If printlevel=1, progress debug messages will be printed,
         if printlevel>=2, all the debug messages will be printed.
EXAMPLE: example BernsteinSatoIdeal; shows examples
"
{
  int ppl = printlevel-voice+2;
  dbprint(ppl,"// enter BernsteinSatoIdeal");
  dbprint(ppl-1, F);
  dbprint(ppl-1, #);
  int eng = 0;
  int met = 0;
  int usesyz = 0;
  if ( size(#)>0 )
  {
    if ( typeof(#[1]) == "int" )
    {
      eng = int(#[1]);
    }
    if ( size(#)>1 )
    {
      if ( typeof(#[2]) == "int" )
      {
        met = int(#[2]);
      }
    }
    if ( size(#)>2 )
    {
      if ( typeof(#[3]) == "int" )
      {
        usesyz = int(#[3]);
      }
    }

  }
  def @R = annihilatorMultiFs(F,eng,usesyz,4);
  //If B_Sigma and trivial ideal
  if ((met < 0) && (NF(1,std(F)) == 0)){
    F = 1;
  }
  if ( size(#)>1 )
  {
    def @R2 = BSidealFromAnn(F, @R, eng, #[2]);
  }
  else
  {
    def @R2 = BSidealFromAnn(F, @R, eng, 0);
  }
  setring @R2;

  LD = imap(@R,annFs);

  dbprint(ppl,"// exit BernsteinSatoIdeal");

  return(@R2);

}
example
{
  "EXAMPLE:"; echo = 2;
  ring R = 0,(x,y),dp;
  ideal F = x^2-y,y;
  // first we compute the ideal B:
  def S = BernsteinSatoIdeal(F);
  setring S;
  BS;
  // secondly we compute the ideal B_1:
  setring R;
  def S = BernsteinSatoIdeal(F,0,1);
  setring S;
  BS;
  // thirdly we compute the ideal B_sigma:
  setring R;
  def S = BernsteinSatoIdeal(F,0,-1);
  setring S;
  BS;
}

proc BFBoundsBudur(ideal F,intvec m)
"USAGE:  BFBoundsBudur(F,m); F an ideal, m an intvec
RETURN:  ring
ASSUME:  basering is a commutative polynomial ring in characteristic 0
PURPOSE: determine upper and lower bounds of the Bernstein-Sato ideal associated to m with
         the method of (Bud12)
NOTE:    The returned ring contains lists Bj, containing the Bernstein-Sato ideals
         associated to e_j,
         shiftedIdeals, containing the shifted ideals from (Bud12) 4.7,
         and ideals upperBound, lowerBound which give upper bound and lower bound
         for the Bernstein-Sato-Ideal associated to m respectively.
EXAMPLE: example BFBoundsBudur; shows example
"
{
  if (!isCommutative())
  {
    ERROR("Basering is not commutative.");
  }
  if(ncols(F) != size(m))
  {
    ERROR("F and m do not have the same size.");
  }

  int ppl = printlevel - voice + 2;

  ring backup = basering;

  int r = ncols(F);
  int n = nvars(basering);
  int k;
  int i;

  //construct k[_s] and prepare map from k<_x,_d,_s> to k[_s]
  ring ks = 0,(s(1..r)),dp;
  setring ks;
  //SGen will be used to map only the s(i)
  ideal SGen;
  SGen[2*n] = 0;
  SGen = maxideal(1),SGen;
  map fetchS;

  ring R; //<--order of the commands important!!!
  setring backup;
  list Bj;

  //compute the B_j
  ring AR = annihilatorMultiFs(F);
  dbprint(ppl,"//starting computation of Bj...");
  for(int j=1; j<=r; j++){
    setring backup;
    R = BSidealFromAnn(F,AR,0,j);
    setring ks;
    fetchS = R,SGen;
    Bj[j] = fetchS(BS);
  }

  //compute the products and intersections
  dbprint(ppl,"//computing upper bounds and lower bounds...");
  ideal upperBound = 1;
  ideal lowerBound = 1;
  ideal tempIdeal;
  //map to shift (now identity map)
  ideal mShifted = s(1);
  for(i=2; i<=r; i++){
    mShifted = mShifted, s(i);
  }
  map shift = ks, mShifted;

  list shiftedIdeals;
  for(j=1; j<=r; j++){
    if(m[j]>0){
      for(k=0; k<m[j]; k++){
        //construct tempIdeal as shift of Bj[j]
        tempIdeal = Bj[j];
        tempIdeal = shift(tempIdeal);
        mShifted[j] = mShifted[j]+1;
        shift = ks, mShifted;
        shiftedIdeals[j] = tempIdeal;
        upperBound = intersect(upperBound, tempIdeal);
        lowerBound = lowerBound*tempIdeal;
      }
    }
  }

  dbprint(ppl,"B_j:");
  dbprint(ppl,string(Bj));
  dbprint(ppl,"upper bound (intersection):");
  dbprint(ppl,string(upperBound));
  dbprint(ppl,"lower bound (product):");
  dbprint(ppl,string(lowerBound));

  export Bj;
  export shiftedIdeals;
  export upperBound;
  export lowerBound;
  return(ks);
}
example
{
  "EXAMPLE:"; echo = 2;
  ring r = 0,(x,y,z),dp;
  setring r;
  ideal F = x*z,2*x^2*y^2*z+x^4+y^4;
  def A = BFBoundsBudur(F,intvec(1,1));
  setring A;
  lead(upperBound);
  lead(lowerBound);
}

proc annfalphaI(ideal f, ideal alpha)
"USAGE:  annfalphaI(f,alpha); f,alpha ideals
RETURN:  ring
ASSUME:  basering is a commutative polynomial ring in characteristic 0
PURPOSE: determine annihilator of f^alpha with the method of (OT99)
NOTE:    The returned ring contains the annihilator of f^alpha over D as annfalpha.
         alpha should contain the desired rational exponents.
         The procedure may also be applied to the univariate case, i.e. for r=1.
EXAMPLE: example annfalphaI; shows example
"
{
  if (!isCommutative())
  {
    ERROR("Basering is not commutative.");
  }
  if(ncols(f) != ncols(alpha))
  {
    ERROR("Parameters f and alpha do not have the same size.")
  }

  int ppl = printlevel-voice+2;
  intvec saveopt=option(get);
  option(redSB);


  ring backup = basering;
  int r = ncols(f);
  int n = nvars(basering);
  int k;

  //construct k[_s] and prepare map from k<_x,_d,_s> to k[_s]
  ring kS = 0,(s(1..r)),dp;
  setring kS;
  ideal SGen;
  SGen[2*n] = 0;
  SGen = SGen,maxideal(1);
  map fetchS;

  setring backup;
  dbprint(ppl,"//starting computation of B and ann(f^s)...");
  def A = annfsBMI(f);
  dbprint(ppl,"//finished computation of B and ann(f^s)...");

  setring kS;
  //identity map on the s(i)
  fetchS = A, SGen;
  def B = fetchS(BS);
  //push numbers through rings
  ideal alpha = imap(backup,alpha);

  dbprint(ppl,"B=");
  dbprint(ppl,B);
  dbprint(ppl,"alpha=");
  dbprint(ppl,alpha);

  //map that shifts alpha to the origin
  map alphaShift;
  ideal shiftedS;
  for(int i=1; i<=r; i++){
    shiftedS[i] = s(i)+alpha[i];
  }
  alphaShift = kS, shiftedS;
  //B is shifted such that alpha is the origin
  def shiftedB = alphaShift(B);
  dbprint(ppl,"shiftedB with alpha<->0 =");
  dbprint(ppl,shiftedB);

  ring ks = 0,(s),dp;
  setring ks;
  //projection from kS to ks with s(i)->s
  ideal sCopies = s;
  for(i=1; i<r; i++){
    sCopies = sCopies, s;
  }
  map projS = kS,sCopies;
  //intersection of B with the line p*(1,...,1)
  def projB = projS(shiftedB);
  dbprint(ppl,"intersection of B with p*(1,...,1) projB=");
  dbprint(ppl,projB);

  ideal factorsB;
  //get projB to one format
  if(typeof(projB) == "ideal"){
    projB = std(projB);
    factorsB = factorize(projB[1])[1];
  } else {
    factorsB = projB[1];
  }
  dbprint(ppl,"factors that give the intersection points factorsB=");
  dbprint(ppl,factorsB);

  int c0 = 0;
  number c;

  //find the minimal integer of B in alpha-c(1,...,1), alpha-c0(1,...,1)
  for(i=1; i<=ncols(factorsB); i++){
    c = number(subst(factorsB[i],s,0));
    if ( isInt(c) && (c > c0) ){
      c0 = int(c);
    }
  }
  dbprint(ppl,"necessary bishop's steps to the minimal important root c0=");
  dbprint(ppl,c0);

  setring A;
  //alpha0 is the minimal integer root of B in alpha-c(1,...,1)
  ideal alpha0 = imap(backup,alpha);
  for(i=1; i<=r; i++){
    alpha0[i] = alpha0[i] - c0;
  }
  dbprint(ppl,"minimal integer root of B in alpha-c(1,...,1) alpha0=");
  dbprint(ppl,alpha0);

  //compute ann_D(f^alpha0)
  ideal annfalpha0 = LD;
  for(i=1; i<=r; i++){
    annfalpha0 = subst(annfalpha0, var(2*n+i), alpha0[i]);
  }
  dbprint(ppl,"annfalpha0=");
  dbprint(ppl, annfalpha0);

  ideal annfalpha;
  if(c0 == 0){
    annfalpha = annfalpha0;
    dbprint(ppl,"no syzygies needed");
  } else {
    //c0 is non-trivial, we need to compute syzygies
    dbprint(ppl,"computing syzygies");
    poly F = product(imap(backup, f));
    matrix J[1][1] = F^c0;
    matrix K[1][size(annfalpha0)] = annfalpha0;
    module M = modulo(J,K);
    annfalpha = ideal(M);
  }

  annfalpha = std(annfalpha);

  dbprint(ppl,"annfalpha=");
  dbprint(ppl,annfalpha);

  export annfalpha;
  option(set,saveopt);
  return(A);
}
example
{
  "EXAMPLE:"; echo = 2;
  ring R = 0,(x,y,z),dp;
  ideal f = x,y,z;
  ideal alpha = 1/4, 2/3, 1;
  def A = annfalphaI(f,alpha);
  setring A;
  annfalpha;
}

proc extractS(ideal I, int r)
"USAGE:  extractS(I,r); I ideal, r int
RETURN:  ring
ASSUME:  I is an ideal in the first r variables of the basering and these r variables generate a commutative subring
PURPOSE: give the ideal generated by I in the commutative subring generated by the first r variables, ordering dp
NOTE:    The returned ring contains I.
EXAMPLE: example extractS; shows example
"
{
  int ppl = printlevel-voice+2;
  def save = basering;
  int N = nvars(basering);
  if (r > N)
  {
    ERROR("Argument r not consistent with basering");
  }

  list RL = ringlist(basering);
  list L, Lord;
  L[1] = RL[1];  //char
  L[4] = RL[4];  //char, minpoly
  // construct list of varnames
  list Name  = RL[2];
  list RName;
  int j;
  for (j=1; j<=r; j++)
  {
    RName[j] = Name[j];
  }
  L[2]   = RName;
  L[3]    = list(list("dp",intvec(1:r)));
  // we are done with the list
  def @R = ring(L);
  setring @R;
  ideal I = imap(save,I);
  export I;
  return(@R);
}
example
{
  "EXAMPLE:"; echo = 2;
  ring R = 0,(x,y),dp;
  ideal f = x^2-y^2,y;
  def S = BernsteinSatoIdeal(f);
  setring S;
  BS;
  def T = extractS(BS,2);
  setring T;
  I;
  factorize(I[1]);
}
