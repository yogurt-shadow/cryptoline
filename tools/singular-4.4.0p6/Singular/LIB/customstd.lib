///////////////////////////////////////////////////////////////////////////////
version="version customstd.lib 4.1.2.0 Feb_2019 ";
category = "Commutative Algebra";
info="
LIBRARY:  customstd.lib   Load customstd.so

AUTHORS:  Hans Schoenemann, hannes at mathematik.uni-kl.de
          Yue Ren, ren at mathematik.uni-kl.de

OVERVIEW:
This library offers customly modified standard bases algorithms
in order to increase the performance of other algorithms.
If you require a customly modified standard bases algorithm,
please contact the authors.

PROCEDURES:

monomialabortstd(ideal);
satstd(ideal, [...]);
";

///////////////////////////////////////////////////////////////////////////////
proc monomialabortstd(ideal I)
"USAGE:   monomialabortstd(I); I ideal
PURPOSE: computes a standard basis and aborts if a monomial generator is found.
         Returns all standard basis elements that have been computed.
NOTE:    Due to sequencing of the standard basis computation:
         - If aborted, there is no guarantee that the monomial is the final
           standard bases element
         - If ideal has a monomial generator, there is no guarantee that the
           computation aborts because of it
KEYWORDS: standard bases.
EXAMPLE: example monomialabortstd; shows an example
"
{
	return (monomialabortstdInternal(I));
}
example
{ "EXAMPLE:"; echo=2;
  LIB "polylib.lib";
  ring r = 0,(x,y,z,u,v),dp;
  // yields normal standard basis since no monomial is found
  ideal I = homog(cyclic(4),v);
  monomialabortstd(I);
  // will not start standard basis computation in the first place,
  // as one of the generators is a monomial
  I = v,homog(cyclic(4),v);
  monomialabortstd(I);
  // aborts standard basis computation when it encounters monomial u
  // note that u is not the final element in the standard basis!!!
  I = x+y+z,homog(cyclic(4),v);
  monomialabortstd(I);
  // aborts standard basis computation when it encounters monomial z2
  // note that it is not the monomial generator x which lead to the abortion!!!
  I = x,homog(cyclic(4),v);
  monomialabortstd(I);
}

proc satstd(ideal I, list #)
"USAGE:   satstd(I[,J]); I ideal, J optional ideal
ASSUME:  J generated by variables
PURPOSE: computes a standard basis of I and, if possible,
         divides each polynomial during the computation by the variables in J.
         By default, J is assumed to be the ideal generated by all variables.
NOTE:    Even if I contains a monomial generated by the variables in J,
         there is no guarantee that it is found during the computation.
         If it is found, however, 1 is immediately returned.
NOTE:    The result is a standard basis of a partially saturated ideal wrt. the
         the variables in J.
	 If the I is homogeneous and the ordering dp, the result is completely
	 saturated wrt. to the last variable (wrt. to the first for Dp).
KEYWORDS: standard bases, saturation
EXAMPLE: example satstd; shows an example
"
{
	if (size(#)>0)
	{
		return (satstdInternal(I,#[1]));
	}
	return (satstdInternal(I));
}
example
{ "EXAMPLE:"; echo=2;
  ring r = 0,(x,y,z,u,v),dp;
  ideal I = x2+x,y2+y,z2+z;
  // returns normal standard basis, no changes during (trivial) computation
  satstd(I,ideal(u,v));
  // returns x+1 instead of x2+x
  satstd(I,ideal(x));
  // returns standard basis with elements of degree up to 8 (instead of 16)
  deg(satstd(I^8));
}

static proc mod_init()
{
  intvec save=option(get);
  option(noredefine);
  LIB "customstd.so";
  option(set,save);
}
