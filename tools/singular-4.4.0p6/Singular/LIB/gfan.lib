///////////////////////////////////////////////////////////////////////////////
version="version gfan.lib 4.4.0.3 Jun_2024 "; // $Id: b9518fbab08f329704eba8b5596a93044bf24d9c $
category = "Convex Geometry";
info="
LIBRARY:  gfan.lib   Interface to gfan and gfanlib for computations in convex geometry
AUTHORS:  Anders N. Jensen, email: jensen@imf.au.dk
          Yue Ren,          email: ren@mathematik.uni-kl.de
          Frank Seelisch

PROCEDURES:
       fullSpace(n);       cone, the ambient space of dimension n
       origin(n);          cone, the origin in an ambient space of dimension n
       positiveOrthant(n); cone, the positive orthant of dimension n
       ambientDimension(c); the dimension of the ambient space the input lives in
       canonicalizeCone(c); a unique representation of the cone c
       codimension(c);      the codimension of the input
       coneViaPoints(M);    define a cone
       coneViaInequalities(M); define a cone
       coneLink(c,w);       the link of c around w
       containsAsFace(c,d); is d a face of c
       containsInSupport(c,d); is d contained in c
       containsPositiveVector(c); contains a vector with only positive entries?
       containsRelatively(c,p); p in c?
       convexHull(c1,c2);   convex hull
       convexIntersection(c1,c2); convex hull
       dimension(c);         dimension of c
       dualCone(c);          the dual of c
       equations(c);         defining equations of c
       faceContaining(c,w);  the face of c containing w in its relative interior
       facets(c);            the facets of c
       generatorsOfLinealitySpace(c); generators of the lineality space of c
       generatorsOfSpan(c);  generators of the span of c
       getLinearForms(c);    linear forms previously stored in c
       getMultiplicity(c);   multiplicity previously stored in c
       inequalities(c);      inequalities of c
       isFullSpace(c);       is the entire ambient space?
       isOrigin(c);          is the origin?
       isSimplicial(c);      is simplicial?
       linealityDimension(c); the dimension of the lineality space of c
       linealitySpace(c);    the lineality space of c
       negatedCone(c);       the negative of c
       polytopeViaInequalities(M); define a polytope
       polytopeViaPoints(M); define a polytope
       quotientLatticeBasis(c);  basis of Z^n intersected with the span of c modulo Z^n intersected with the lineality space of c
       randomPoint(c);       a random point in the relative interior of c
       rays(c);              generators of the rays of c
       relativeInteriorPoint(c); point in the relative interior of c
       semigroupGenerator(c); generator of Z^n intersected with c modulo Z^n intersected with the lineality space of c
       setLinearForms(c);    stores linear forms in c
       setMultiplicity(c);   stores a multiplicity in c
       span(c);              unique irredundant equations of c
       uniquePoint(c);       a unique point in c stable under reflections at coordinate hyperplanes
       containsInCollection(f,c); f contains c?
       emptyFan(n);           empty fan in ambient dimension n
       fanViaCones(L);        fan generated by the cones in L
       fullFan(n);            full fan in ambient dimension n
       fVector(f);            the f-Vector of f
       getCone(f,d,i[,m]);  the i-th cone of dimension d in f
       insertCone(f,c[,b]);   inserts the cone c into f
       isCompatible(f,c);     f and c live in the same ambient space
       isPure(f);             all maximal cones of f are of the same dimension
       nmaxcones(f);          number of maximal cones in f
       ncones(f);             number of cones in f
       numberOfConesOfDimension(f,d[,m]); the number of cones in dimension d
       removeCone(f,c[,b]);   removes the cone c
       dualPolytope(p);       the dual of p
       newtonPolytope(f);     convex hull of all exponent vectors of f
       vertices(p);           vertices of p
       onesVector(n);         intvec of length n with all entries 1
";

///////////////////////////////////////////////////////////////////////////////

/////
// non gfanlib.so functions
/////

proc fullSpace(int n)
"USAGE:   fullSpace(n);  n int
RETURN:  cone, the ambient space of dimension n
EXAMPLE: example positiveOrthant; shows an example
"
{
  cone c = n;
  return (c);
}
example
{
  "EXAMPLE:"; echo = 2;
  cone c = fullSpace(2);
  generatorsOfLinealitySpace(c);
}

proc origin(int n)
"USAGE:   origin(n);  n int
RETURN:  cone, the origin in an ambient space of dimension n
EXAMPLE: example origin; shows an example
"
{
  bigintmat ineq[0][n];
  bigintmat eq[n][n];
  for (int i=1; i<=n; i++)
  {
    eq[i,i]=1;
  }
  cone o = coneViaInequalities(ineq,eq);
  return (o);
}
example
{
  "EXAMPLE:"; echo = 2;
  cone c = origin(2);
  equations(c);
}

proc positiveOrthant(int n)
"USAGE:   positiveOrthant(n);  n int
RETURN:  cone, the positive orthant of dimension n
EXAMPLE: example positiveOrthant; shows an example
"
{
  bigintmat ineq[n][n];
  for (int i=1; i<=n; i++)
  {
    ineq[i,i]=1;
  }
  cone posOrthant = coneViaInequalities(ineq);
  return (posOrthant);
}
example
{
  "EXAMPLE:"; echo = 2;
  cone c = positiveOrthant(2);
  rays(c);
}

/////
// gfan interface functions
/////

static proc intmatToGfanVectorConfiguration(intmat P)
{
  string gfanVectorConfiguration = "{";
  int c = ncols(P);
  for (int i=1; i<=nrows(P); i++)
  {
    gfanVectorConfiguration = gfanVectorConfiguration
      +"("+string(intvec(P[i,1..c]))+"),";
  }
  int k = size(gfanVectorConfiguration);
  gfanVectorConfiguration = gfanVectorConfiguration[1..k-1];
  gfanVectorConfiguration = gfanVectorConfiguration+"}";
  return (gfanVectorConfiguration);
}

proc secondaryFan(intmat P, def #)
"USAGE:   secondaryFan(P);   P intmat
         secondaryFan(P,s); P intmat, s string
RETURN:  fan, the secondary fan of the vector configuration P
NOTE:    s is a option string that is passed to gfan, possible options are
           `--log1` to `--log3` for output during the computation
EXAMPLE: example secondaryFan; shows an examplex
"
{
  string filename = "/tmp/gfanlib_secondaryFan_"+string(random(1,2147483647));
  string filenameIn = filename+".in.gfan";
  string filenameOut = filename+".out.gfan";

  string filestring = intmatToGfanVectorConfiguration(P);
  filestring;
  write(":w "+filenameIn,filestring);
  int dummy = system("sh","gfan_secondaryfan "+string(#)+" < "+filenameIn+" > "+filenameOut);
  string fanString = read(filenameOut);

  dummy = system("sh","rm "+filenameIn+" "+filenameOut);
  return (fanFromString(fanString));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat P[4][3] =
    1,0,0,
    1,1,0,
    1,0,1,
    1,1,1;
  fan F = secondaryFan(P);
  F;
}

/////
// cone related functions
/////

proc ambientDimension(def coneOrFanOrPolytope)
"USAGE:   ambientDimension(c);  c cone
         ambientDimension(f);  f fan
         ambientDimension(p);  p polytope
RETURN:  int, the dimension of the ambient space the input lives in
EXAMPLE: example ambientDimension; shows an example
"
{
  return (ambientDimensionInternal(coneOrFanOrPolytope));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[2][2]=
    1,0,
    0,1;
  cone c1=coneViaPoints(M1);
  ambientDimension(c1);
  intmat M2[2][3]=
    1,0,0,
    0,1,0;
  cone c2=coneViaPoints(M2);
  ambientDimension(c2);

  fan f = emptyFan(3);
  ambientDimension(f);
}

proc canonicalizeCone(cone c)
"USAGE:   canonicalizeCone(c);  c cone
RETURN:  cone, a unique representation of the cone c
EXAMPLE: example canonicalizeCone; shows an example
"
{
  return (canonicalizeConeInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[5][3]=
    8,1,9,
    9,2,4,
    0,6,2,
    8,8,8,
    0,9,5;
  cone c=coneViaInequalities(M);
  c;
  cone cc=canonicalizeCone(c);
  cc;
  // computes a unique representation of c
  c == cc;
  // some procedures work with the known inequalities and equations
  // in order to obtain a unique output,
  // bring the cone in canonical form beforehand
  relativeInteriorPoint(c);
  relativeInteriorPoint(cc);
}

proc codimension(def coneOrFanOrPolytope)
"USAGE:   codimension(c);  c cone
         codimension(f);  f fan
         codimension(p);  p polytope
RETURN:  int, the codimension of the input
EXAMPLE: example codimension; shows an example
"
{
  return (codimensionInternal(coneOrFanOrPolytope));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[1][2]=
    1,0;
  cone c1=coneViaPoints(M1);
  codimension(c1);
  intmat M2[2][2]=
    1,0,
    0,1;
  cone c2=coneViaPoints(M2);
  codimension(c2);

  fan f = emptyFan(2);
  codimension(f);
  insertCone(f,c1);
  codimension(f);
  insertCone(f,c2);
  codimension(f);
}

proc coneViaPoints(def HL, list #)
"USAGE:   coneViaPoints(HL); intmat HL
          coneViaPoints(HL,L); intmat HL, intmat L
          coneViaPoints(HL,L,flags); intmat HL, intmat L, int flags
RETURN:  cone
PURPOSE: cone generated by half lines generated by the row vectors of HL
  and (if stated) by lines generated by the row vectors of L;
  flags may range between 0,..,3 defining an upper and lower bit
  (0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
  if upper bit is 1, then program assumes that each row vector in HL
  generates a ray of the cone,
  if lower bit is 1, then program assumes that the span of the row
  vectors of L is the lineality space of the cone,
  if either bit is 0, then program computes the information itself.
EXAMPLE: example coneViaPoints; shows an example
"
{
  if (size(#)==2)
  {
    return (coneViaPointsInternal(HL,#[1],#[2]));
  }
  if (size(#)==1)
  {
    return (coneViaPointsInternal(HL,#[1]));
  }
  return (coneViaPointsInternal(HL));
}
example
{
  "EXAMPLE:"; echo = 2;
  // Let's define a cone in R^3 generated by the following half lines:
  intmat HL[5][3]=
   1,0, 0,
  -1,0, 0,
   0,1, 1,
   0,1,-1,
   0,0, 1;
  cone c=coneViaPoints(HL);
  c;
  kill HL,c;
  // Note that (1,0,0) and (-1,0,0) form a line, hence also possible:
  intmat HL[3][3]=
  0,1, 1,
  0,1,-1,
  0,0, 1;
  intmat L[1][3]=
  1,0,0;
  cone c=coneViaPoints(HL,L);
  c;
  kill HL,L,c;
  // lineality space is exactly Lin(1,0,0)
  intmat HL[3][3]=
  0,1, 1,
  0,1,-1,
  0,0, 1;
  intmat L[1][3]=
  1,0,0;
  cone c=coneViaPoints(HL,L,1);
  c;
  kill HL,L,c;
  // and that (0,1,-1), (0,1,1) generate rays
  intmat HL[3][3]=
  0,1, 1,
  0,1,-1;
  intmat L[1][3]=
  1,0,0;
  cone c=coneViaPoints(HL,L,1);
  c;
  kill HL,L,c;
  // and that (0,1,-1), (0,1,1) generate rays
  intmat HL[3][3]=
  0,1, 1,
  0,1,-1;
  intmat L[1][3]=
  1,0,0;
  cone c=coneViaPoints(HL,L,3);
  c;
}

proc coneViaInequalities(def E, list #)
"USAGE:   coneViaInequalities(IE); intmat IE
          coneViaInequalities(IE,E); intmat IE, intmat E
          coneViaInequalities(IE,E,flags); intmat IE, intmat E, int flags
RETURN:  cone
PURPOSE: cone consisting of all points x, such that IE*x >= 0 in each component
  and (if stated) E*x = 0;
  inequalities and (if stated) equations will be transformed, getting rid of
  redundancies;
  flags may range between 0,..,3 defining an upper and lower bit
  (0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
  if higher bit is 1, then program assumes each inequality yields a facet,
  if lower bit is 1, then program assumes the kernel of E is the span of the cone,
  if either bit is 0, then program computes the information itself.
EXAMPLE: example coneViaInequalities; shows an example
"
{
  if (size(#)==2)
  {
    return (coneViaInequalitiesInternal(E,#[1],#[2]));
  }
  if (size(#)==1)
  {
    return (coneViaInequalitiesInternal(E,#[1]));
  }
  return (coneViaInequalitiesInternal(E));
}
example
{
  "EXAMPLE:"; echo = 2;
  // Let's define a cone in R^3 given by the following inequalities:
  intmat IE[6][3]=
  1,3,5,
  1,5,3,
  0,1,-1,
  0,1,1,
  1,0,0,
  -1,0,0;
  cone c=coneViaInequalities(IE);
  c;
  // Note that the last two inequalities yield x1 = 0, hence also possible:
  intmat IE[4][3]=
  0,1,-1,
  0,1,1;
  intmat E[1][3]=
  1,0,0;
  cone c=coneViaInequalities(IE,E);
  c;
  // each inequalities gives rise to a facet
  intmat IE[2][3]=
  0,1,-1,
  0,1,1;
  intmat E[1][3]=
  1,0,0;
  cone c=coneViaInequalities(IE,E,1);
  c;
  // and the kernel of E is the span of the cone
  intmat IE[2][3]=
  0,1,-1,
  0,1,1;
  intmat E[1][3]=
  1,0,0;
  cone c=coneViaInequalities(IE,E,3);
  c;
}

proc coneLink(cone c, def w)
"USAGE:   coneLink(c,w);  c cone, w intvec/bigintmat
RETURN:  cone, the link of c around w
EXAMPLE: example coneLink; shows an example
"
{
  return (coneLinkInternal(c,w));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[3][3]=
    1,0,0,
    0,1,0,
    0,0,1;
  cone c=coneViaPoints(M);
  intvec v=1,0,0;
  cone cv=coneLink(c,v);
  rays(cv);
  generatorsOfLinealitySpace(cv);
  intvec w=1,1,1;
  cone cw=coneLink(c,w);
  rays(cw);
  generatorsOfLinealitySpace(cw);
}

proc containsAsFace(cone c, cone d)
"USAGE:   containsAsFace(c,d);  c cone, d cone
RETURN:  1, if d is a face of c; 0 otherwise
EXAMPLE: example containsAsFace; shows an example
"
{
  return (containsAsFaceInternal(c,d));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][2]=
    1,0,
    0,1;
  cone c=coneViaPoints(M);
  intmat N1[1][2]=
    1,1;
  cone d1=coneViaPoints(N1);
  containsInSupport(c,d1);
  containsAsFace(c,d1);
  intmat N2[1][2]=
    0,1;
  cone d2=coneViaPoints(N2);
  containsInSupport(c,d2);
  containsAsFace(c,d2);
}

proc containsRelatively(cone c, def p)
"USAGE:   containsRelatively(c,p);  c cone, p intvec/bigintmat
RETURN:  1 iff the given cone contains the given point in its relative interior; 0 otherwise
EXAMPLE: example containsRelatively; shows an example
"
{
  return (containsRelativelyInternal(c,p));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][2]=
  1,0,
  0,1;
  cone c=coneViaPoints(M);
  intvec p1=1,1;
  containsRelatively(c,p1);
  intvec p2=0,1;
  containsRelatively(c,p2);
}

proc containsInSupport(cone c, def d)
"USAGE:   containsInSupport(c,d);  c cone, d cone
         containsInSupport(c,p);   c cone, p intvec/bigintmat
RETURN:  1, if d resp. p is contained in c; 0 otherwise
EXAMPLE: example containsInSupport; shows an example
"
{
  return (containsInSupportInternal(c,d));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][2]=
    1,0,
    0,1;
  cone c=coneViaPoints(M);
  containsInSupport(c,c);
  intmat N1[2][2]=
    1,1,
    0,1;
  cone d1=coneViaPoints(N1);
  containsInSupport(c,d1);
  intmat N2[2][2]=
    1,1,
    1,-1;
  cone d2=coneViaPoints(N2);
  containsInSupport(c,d2);
  intvec p1=0,1;
  containsInSupport(c,p1);
  intvec p2=1,-1;
  containsInSupport(c,p2);
}

proc containsPositiveVector(cone c)
"USAGE:   containsPositiveVector(c);  c cone
RETURN:  1, if c contains a vector with only positive entries in its relative interior
EXAMPLE: example containsPositiveVector; shows an example
"
{
  return (containsPositiveVectorInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[2][2]=
    1,1,
    1,-1;
  cone c1=coneViaPoints(M1);
  containsPositiveVector(c1);
  intmat M2[2][2]=
    0,1,
    -1,0;
  cone c2=coneViaPoints(M2);
  containsPositiveVector(c2);
}

proc convexHull(def coneOrPolytope1, def coneOrPolytope2)
"USAGE:   convexHull(c1,c2);   c1 cone, c2 cone
         convexHull(c1,p1);   c1 cone, p1 polytope
         convexHull(p1,c1);   p1 cone, c1 polytope
         convexHull(p1,p2);   p1 polytope, p2 polytope
RETURN:  cone resp polytope, the convex hull of its two input objects
EXAMPLE: example convexHull; shows an example
"
{
  return (convexHullInternal(coneOrPolytope1,coneOrPolytope2));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[2][2]=
    1,0,
    0,1;
  cone c1=coneViaPoints(M1);
  intmat M2[2][2]=
    1,1,
    1,-1;
  cone c2=coneViaPoints(M2);
  intmat M3[2][2]=
    1,0,
    0,-1;
  cone c3=coneViaPoints(M3);
  cone c12=convexHull(c1,c2);
  c12;
  print(rays(c12));
  cone c23=convexHull(c2,c3);
  c23;
  print(rays(c23));
  cone c13=convexHull(c1,c3);
  c13;
  print(rays(c13));
}

proc convexIntersection(list #)
"USAGE:   convexIntersection(c1,c2);   c1 cone, c2 cone
         convexIntersection(c1,p1);   c1 cone, p1 polytope
         convexIntersection(p1,c1);   p1 cone, c1 polytope
         convexIntersection(p1,p2);   p1 polytope, p2 polytope
                           convexIntersection(L);   L list of cones resp polytopes
RETURN:  cone resp polytope, the convex hull of its two input objects
EXAMPLE: example convexIntersection; shows an example
"
{
  if (typeof(#[1])=="list")
  {
    return (convexIntersectionInternal(#[1]));
  }
  return (convexIntersectionInternal(#));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[2][2]=
    1,0,
    0,1;
  cone c1=coneViaPoints(M1);
  intmat M2[2][2]=
    1,1,
    1,-1;
  cone c2=coneViaPoints(M2);
  intmat M3[2][2]=
    1,0,
    0,-1;
  cone c3=coneViaPoints(M3);
  cone c12=convexIntersection(c1,c2);
  c12;
  print(rays(c12));
  cone c23=convexIntersection(c2,c3);
  c23;
  print(rays(c23));
  cone c13=convexIntersection(c1,c3);
  c13;
  print(rays(c13));
}

proc dimension(def coneOrFanOrPolytope)
"USAGE:   dimension(c);  c cone
         dimension(f);  f fan
         dimension(p);  p polytope
RETURN:  int, the dimension of the input
EXAMPLE: example dimension; shows an example
"
{
  return (dimensionInternal(coneOrFanOrPolytope));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[1][2]=
    1,0;
  cone c1=coneViaPoints(M1);
  dimension(c1);
  intmat M2[2][2]=
    1,0,
    0,1;
  cone c2=coneViaPoints(M2);
  dimension(c2);

  fan f = emptyFan(2);
  dimension(f);
  insertCone(f,c1);
  dimension(f);
  insertCone(f,c2);
  dimension(f);
}

proc dualCone(cone c)
"USAGE:   dualCone(c);  c cone
RETURN:  cone, the dual of c
EXAMPLE: example dualCone; shows an example
"
{
  return (dualConeInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[2][2]=
    1,0,
    0,1;
  cone c1=coneViaPoints(M1);
  cone d1=dualCone(c1);
  d1;
  print(rays(d1));
  intmat M2[2][2]=
    1,1,
    0,1;
  cone c2=coneViaPoints(M2);
  cone d2=dualCone(c2);
  d2;
  print(rays(d2));
}

proc equations(def coneOrPolytope)
"USAGE:   equations(c);  c cone
         equations(p);  p polytope
RETURN:  bigintmat, defining equations of c resp p
NOTE:    neither unique nor complete, unless c resp p in canonical form
EXAMPLE: example equations; shows an example
"
{
  return (equationsInternal(coneOrPolytope));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[2][2]=
    1,0,
    0,1;
  cone c1=coneViaPoints(M1);
  bigintmat E1=equations(c1);
  print(E1);
  intmat M2[1][2]=
    1,0;
  cone c2=coneViaPoints(M2);
  bigintmat E2=equations(c2);
  print(E2);
}

proc faceContaining(cone c, def w)
"USAGE:   faceContaining(c,w);  c cone, w intvec/bigintmat
ASSUME:  containsInSupport(c,w)==1
RETURN:  cone, the face of c containing w in its relative interior
EXAMPLE: example faceContaining; shows an example
"
{
  return (faceContainingInternal(c,w));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][2]=
    1,0,
    0,1;
  cone c=coneViaPoints(M);
  faceContaining(c,intvec(1,0));
  faceContaining(c,intvec(0,1));
  faceContaining(c,intvec(1,1));
  faceContaining(c,intvec(0,0));
}

proc facets(def coneOrPolytope)
"USAGE:   facets(c);  c cone
         facets(p);  p polytope
RETURN:  bigintmat, the facets of c resp p
EXAMPLE: example facets; shows an example
"
{
  return (facetsInternal(coneOrPolytope));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[2][2]=
    1,0,
    0,1;
  cone c1=coneViaPoints(M1);
  bigintmat F1=facets(c1);
  print(F1);
  intmat M2[2][2]=
    1,1,
    0,-1;
  cone c2=coneViaPoints(M2);
  bigintmat F2=facets(c2);
  print(F2);
}

proc generatorsOfLinealitySpace(cone c)
"USAGE:   generatorsOfLinealitySpace(c);  c cone
RETURN:  bigintmat, generators of the lineality space of c
EXAMPLE: example generatorsOfLinealitySpace; shows an example
"
{
  return (generatorsOfLinealitySpaceInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[5][3]=
    1,0,0,
    0,1,0,
    0,0,1,
    -1,0,0,
    0,-1,0;
  cone c=coneViaPoints(M);
  bigintmat L=generatorsOfLinealitySpace(c);
  print(L);
}

proc generatorsOfSpan(cone c)
"USAGE:   generatorsOfSpan(c);  c cone
RETURN:  bigintmat, generators of the span of c
EXAMPLE: example generatorsOfSpan; shows an example
"
{
  return (generatorsOfSpanInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[3][5]=
    1,0,0,0,0,
    0,1,0,0,0,
    0,0,1,0,0;
  cone c=coneViaPoints(M);
  bigintmat S=generatorsOfSpan(c);
  print(S);
}

proc getLinearForms(def coneOrPolytope)
"USAGE:   getLinearForms(c);  c cone
         getLinearForms(p);  p polytope
RETURN:  bigintmat, linear forms previously stored in c resp p
EXAMPLE: example getLinearForms; shows an example
"
{
  return (getLinearFormsInternal(coneOrPolytope));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][3]=
    -1,0,0,
    0,-1,0;
  cone c=coneViaPoints(M);
  getLinearForms(c);
  intvec v=1,1,1;
  setLinearForms(c,v);
  getLinearForms(c);
}

proc getMultiplicity(def coneOrPolytope)
"USAGE:   getMultiplicity(c);  c cone
         getMultiplicity(p);  p polytope
RETURN:  bigint, 1 or a multiplicity previously stored in c resp p
EXAMPLE: example getMultiplicity; shows an example
"
{
  return (getMultiplicityInternal(coneOrPolytope));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][3]=
    -1,0,0,
    0,-1,0;
  cone c=coneViaPoints(M);
  getMultiplicity(c);
  setMultiplicity(c,3);
  getMultiplicity(c);
}

proc inequalities(def coneOrPolytope)
"USAGE:   inequalities(c);  c cone
         inequalities(p);  p polytope
RETURN:  bigintmat, the inequalities of c resp p
NOTE:    neither unique nor irredundant, unless c resp p in canonical form
EXAMPLE: example inequalities; shows an example
"
{
  return (inequalitiesInternal(coneOrPolytope));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[2][2]=
    1,0,
    0,1;
  cone c1=coneViaPoints(M1);
  bigintmat I1=inequalities(c1);
  print(I1);
  intmat M2[2][2]=
    1,1,
    0,-1;
  cone c2=coneViaPoints(M2);
  bigintmat I2=inequalities(c2);
  print(I2);
}

proc isFullSpace(cone c)
"USAGE:   isFullSpace(c);  c cone
RETURN:  1, if c is the entire ambient space; 0 otherwise
EXAMPLE: example isFullSpace; shows an example
"
{
  return (isFullSpaceInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  cone c1;
  isFullSpace(c1);
  intmat M2[2][2]=
    1,0,
    0,1;
  cone c2=coneViaPoints(M2);
  isFullSpace(c2);
  intmat M3[4][2]=
    1,0,
    0,1,
    -1,0,
    0,-1;
  cone c3=coneViaPoints(M3);
  isFullSpace(c3);
}

proc isOrigin(cone c)
"USAGE:   isOrigin(c);  c cone
RETURN:  1, if c is the origin; 0 otherwise
EXAMPLE: example isOrigin; shows an example
"
{
  return (isOriginInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  cone c1;
  isOrigin(c1);
  intmat M2[2][2]=
    1,0,
    0,1;
  cone c2=coneViaPoints(M2);
  isOrigin(c2);
  intmat M3[4][2]=
    1,0,
    0,1,
    -1,0,
    0,-1;
  cone c3=coneViaPoints(M3);
  isOrigin(c3);
}

proc isSimplicial(def coneOrFan)
"USAGE:   isSimplicial(c);  c cone
         isSimplicial(f);  f fan
RETURN:  1, if c resp f is simplicial; 0 otherwise
EXAMPLE: example isSimplicial; shows an example
"
{
  return (isSimplicialInternal(coneOrFan));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[3][3]=
    1,0,0,
    0,1,0,
    0,0,1;
  cone c1=coneViaPoints(M1);
  isSimplicial(c1);
  intmat M2[4][3]=
    1,0,0,
    0,1,0,
    0,0,1,
    1,1,-1;
  cone c2=coneViaPoints(M2);
  isSimplicial(c2);
  /***********************/
  fan f=emptyFan(3);
  isSimplicial(f);
  intmat N1[3][3]=
    1,0,0,
    0,1,0,
    0,0,1;
  cone d1=coneViaPoints(N1);
  insertCone(f,d1);
  isSimplicial(f);
  intmat N2[4][3]=
    1,0,0,
    0,1,0,
    1,0,-1,
    0,1,-1;
  cone d2=coneViaPoints(N2);
  insertCone(f,d2);
  isSimplicial(f);
}

proc linealityDimension(def coneOrFan)
"USAGE:   linealityDimension(c);  c cone
         linealityDimension(f);  f fan
RETURN:  int, the dimension of the lineality space of c resp f
EXAMPLE: example linealityDimension; shows an example
"
{
  return (linealityDimensionInternal(coneOrFan));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[3][3]=
    1,0,0,
    0,1,0,
    0,0,1;
  cone c1=coneViaPoints(M1);
  linealityDimension(c1);
  intmat M2[4][3]=
    1,0,0,
    0,1,0,
    0,0,1,
    -1,0,0;
  cone c2=coneViaPoints(M2);
  linealityDimension(c2);
}

proc linealitySpace(cone c)
"USAGE:   linealitySpace(c);  c cone
RETURN:  cone, the lineality space of c
EXAMPLE: example linealitySpace; shows an example
"
{
  return (linealitySpaceInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[3][3]=
    1,0,0,
    0,1,0,
    0,0,1;
  cone c1=coneViaPoints(M1);
  cone l1=linealitySpace(c1);
  l1;
  intmat M2[4][3]=
    1,0,0,
    0,1,0,
    0,0,1,
    -1,0,0;
  cone c2=coneViaPoints(M2);
  cone l2=linealitySpace(c2);
  l2;
}

proc negatedCone(cone c)
"USAGE:   negatedCone(c);  c cone
RETURN:  cone, the negative of c
EXAMPLE: example negatedCone; shows an example
"
{
  return (negatedConeInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][2]=
    1,0,
    0,1;
  cone c=coneViaPoints(M);
  cone cn=negatedCone(c);
  print(rays(cn));
}

proc quotientLatticeBasis(cone c)
"USAGE:   quotientLatticeBasis(c);  c cone
RETURN:  bigintmat, a basis of Z^n intersected with the span of c modulo Z^n intersected with the lineality space of c
EXAMPLE: example quotientLatticeBasis; shows an example
"
{
  return (quotientLatticeBasisInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[3][2]=
    1,0,
    0,1,
    -1,0;
  cone c=coneViaPoints(M);
  bigintmat Q=quotientLatticeBasis(c);
  print(Q);
}

proc randomPoint(cone c, list #)
"USAGE:   randomPoint(c);  c cone
         randomPoint(c,b);  c cone, b int
RETURN:  bigintmat, a random point in the relative interior of c
NOTE:    returns a weighted sum over all its rays
         if b is given and b>0, only chooses weights between 1 and b
EXAMPLE: example randomPoint; shows an example
"
{
  if (size(#)==1)
  {
    return (randomPointInternal(c,#[1]));
  }
  return (randomPointInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][2]=
    1,0,
    0,1;
  cone c=coneViaPoints(M);
  bigintmat Q=randomPoint(c);
  print(Q);
  bigintmat P=randomPoint(c,5);
  print(P);
}

proc rays(cone c)
"USAGE:   rays(c);  c cone
RETURN:  bigintmat, generators of the rays of c, orthogonal to its lineality space
EXAMPLE: example rays; shows an example
"
{
  return (raysInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[2][2]=
    1,0,
    0,1;
  cone c1=coneViaPoints(M1);
  bigintmat R1=rays(c1);
  print(R1);
  intmat M2[3][2]=
    1,0,
    0,1,
    -1,0;
  cone c2=coneViaPoints(M2);
  bigintmat R2=rays(c2);
  print(R2);
}

proc relativeInteriorPoint(cone c)
"USAGE:   relativeInteriorPoint(c);  c cone
RETURN:  bigintmat, a point in the relative interior of c
NOTE:    not unique, unless c is in its canonical form
EXAMPLE: example relativeInteriorPoint; shows an example
"
{
  return (relativeInteriorPointInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[2][2]=
    1,0,
    0,1;
  cone c1=coneViaPoints(M1);
  relativeInteriorPoint(c1);
  intmat M2[2][2]=
    1,0,
    1,1;
  cone c2=coneViaPoints(M2);
  relativeInteriorPoint(c2);
}

proc semigroupGenerator(cone c)
"USAGE:   semigroupGenerator(c);  c cone
RETURN:  bigintmat, the generator of Z^n intersected with c modulo Z^n intersected with the lineality space of c
ASSUME:  dimension(c) == linealityDimension(c)+1
EXAMPLE: example semigroupGenerator; shows an example
"
{
  return (semigroupGeneratorInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[3][2]=
    1,0,
    0,1,
    -1,0;
  cone c=coneViaPoints(M);
  semigroupGenerator(c);
}

proc setLinearForms(alias def coneOrPolytope, intvec v)
"USAGE:   setLinearForms(c,v);  c cone, v intvec
         setLinearForms(p,v);  p polytope, v intvec
RETURN:  none, stores linear forms in c resp p
EXAMPLE: example setLinearForms; shows an example
"
{
  return (setLinearFormsInternal(coneOrPolytope,v));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][3]=
    -1,0,0,
    0,-1,0;
  cone c=coneViaPoints(M);
  getLinearForms(c);
  intvec v=1,1,1;
  setLinearForms(c,v);
  getLinearForms(c);
}

proc setMultiplicity(alias def coneOrPolytope, int m)
"USAGE:   setMultiplicity(c,m);  c cone, m int
         setMultiplicity(p,m);  p polytope, m int
RETURN:  none, stores a multiplicity in c resp p
EXAMPLE: example setMultiplicity; shows an example
"
{
  return (setMultiplicityInternal(coneOrPolytope,m));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][3]=
    -1,0,0,
    0,-1,0;
  cone c=coneViaPoints(M);
  getMultiplicity(c);
  setMultiplicity(c,3);
  getMultiplicity(c);
}

proc span(cone c)
"USAGE:   span(c);  c cone
RETURN:  bigintmat, unique irredundant equations of c
NOTE:    the name 'span' was chosen to be in line with polymake's nomenclature
EXAMPLE: example span; shows an example
"
{
  return (spanInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[3][5]=
    1,0,0,0,0,
    0,1,0,0,0,
    0,0,1,0,0;
  cone c=coneViaPoints(M);
  bigintmat Eq=span(c);
  print(Eq);
}


proc uniquePoint(cone c)
"USAGE:   uniquePoint(c);  c cone
RETURN:  bigintmat, a unique point in c stable under reflections at coordinate hyperplanes
EXAMPLE: example uniquePoint; shows an example
"
{
  return (uniquePointInternal(c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M1[2][2]=
    1,0,
    0,1;
  cone c1=coneViaPoints(M1);
  uniquePoint(c1);
  intmat M2[2][2]=
    -1,0,
    0,1;
  cone c2=coneViaPoints(M2);
  uniquePoint(c2);
}



/////
// fan related functions
/////

proc containsInCollection(fan f, cone c)
"USAGE:   containsInCollection(f,c);  f fan, c cone
RETURN:  1, if f contains c; 0 otherwise
EXAMPLE: example containsInCollection; shows an example
"
{
  return (containsInCollectionInternal(f,c));
}
example
{
  "EXAMPLE:"; echo = 2;
  fan f=emptyFan(2);
  intmat M[2][2]=
    1,0,
    0,1;
  cone c=coneViaPoints(M);
  containsInCollection(f,c);
  insertCone(f,c);
  containsInCollection(f,c);
}

proc emptyFan(int n)
"USAGE:   emptyFan(n);  n int
RETURN:  fan, an empty fan in ambient dimension n
EXAMPLE: example emptyFan; shows an example
"
{
  return (emptyFanInternal(n));
}
example
{
  "EXAMPLE:"; echo = 2;
  fan f=emptyFan(2);
  f;
}

proc fanViaCones(list #)
"USAGE:   fanViaCones(L);  L list
         fanViaCones(c1[,...,ck]);  c1,...,ck cones
RETURN:  fan, creates a fan generated by the cones in L resp c1,...,ck
EXAMPLE: example fanViaCones; shows an example
"
{
  if (typeof(#[1])=="list")
  {
    return (fanViaConesInternal(#[1]));
  }
  return (fanViaConesInternal(#));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][2]=1,0,0,1;
  cone c=coneViaPoints(M);
  intmat N[2][2]=1,0,0,-1;
  cone d=coneViaPoints(N);
  fan f=fanViaCones(c,d);
  f;
  list L=c,d;
  fan g=fanViaCones(L);
  g;
}

proc fullFan(int n)
"USAGE:   fullFan(n);  n int
RETURN:  fan, an full fan in ambient dimension n
EXAMPLE: example fullFan; shows an example
"
{
  return (fullFanInternal(n));
}
example
{
  "EXAMPLE:"; echo = 2;
  fan f=fullFan(2);
  f;
}

proc fVector(fan f)
"USAGE:   fVector(f);  f fan
RETURN:  bigintmat, the f-Vector of f
EXAMPLE: example fVector; shows an example
"
{
  return (fVectorInternal(f));
}
example
{
  "EXAMPLE:"; echo = 2;
  fan f=emptyFan(2);
  fVector(f);
  intmat M[2][2]=1,0,0,1;
  cone c=coneViaPoints(M);
  insertCone(f,c);
  fVector(f);
}

proc getCone(fan f, int d, int i, list #)
"USAGE:   getCone(f,d,i[,m]);  f fan, d int, i int, m int
ASSUME:  d is between 0 and ambientDimension(f)
         i is between 1 and numberOfConesOfDimension(f,d,o,m)
RETURN:  cone, returns in the fan f of all cones in dimension d the i-th cone
         if m!=0, it will enumerate over maximal cones only
EXAMPLE: example getCone; shows an example
"
{
  if (size(#)==1)
  {
    return (getConeInternal(f,d,i,#[1]));
  }
  return (getConeInternal(f,d,i));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[3][3]=
    1,0,0,
    0,1,0,
    0,0,1;
  cone c=coneViaPoints(M);
  fan f=emptyFan(3);
  insertCone(f,c);
  getCone(f,2,1,0);
  getCone(f,2,2,0);
}

proc insertCone(alias fan f, cone c, list #)
"USAGE:   insertCone(f,c[,b]);  f fan, c cone, b int
ASSUME:  isCompatible(f,c)=1
RETURN:  none, inserts the cone c into f
         if b=0, then skips check whether f and c are compatible
EXAMPLE: example insertCone; shows an example
"
{
  if (size(#)>0)
  {
    insertConeInternal(f,c,#[1]);
    return ();
  }
  insertConeInternal(f,c);
}
example
{
  "EXAMPLE:"; echo = 2;
  fan f=emptyFan(3);
  f;
  intmat M[3][3]=
    1,0,0,
    0,1,0,
    0,0,1;
  cone c=coneViaPoints(M);
  insertCone(f,c);
  f;
}


proc isCompatible(fan f, cone c)
"USAGE:   isCompatible(f,c);  f fan, c cone
RETURN:  1 if f and c live in the same ambient space and
           if the intersection of c with any cone of f is a face of each;
         0 otherwise
EXAMPLE: example isCompatible; shows an example
"
{
  return (isCompatibleInternal(f,c));
}
example
{
  "EXAMPLE:"; echo = 2;
  fan f=emptyFan(3);
  intmat M1[3][3]=
    1,0,0,
    0,1,0,
    0,0,1;
  cone c1=coneViaPoints(M1);
  isCompatible(f,c1);
  insertCone(f,c1);
  intmat M2[3][3]=
    1,1,1,
    1,0,0,
    0,1,0;
  cone c2=coneViaPoints(M2);
  isCompatible(f,c2);
  intmat M3[3][3]=
    1,0,0,
    0,1,0,
    0,0,-1;
  cone c3=coneViaPoints(M3);
  isCompatible(f,c3);
}

proc isPure(fan f)
"USAGE:   isPure(f);  f fan
RETURN:  1 if all maximal cones of f are of the same dimension
         0 otherwise
EXAMPLE: example isPure; shows an example
"
{
  return (isPureInternal(f));
}
example
{
  "EXAMPLE:"; echo = 2;
  fan f=fullFan(2);
  isPure(f);
  fan g=emptyFan(2);
  intmat M1[2][2]=
    1,0,
    0,1;
  cone c1=coneViaPoints(M1);
  insertCone(g,c1);
  isPure(g);
  intmat M2[1][2]=
    0,-1;
  cone c2=coneViaPoints(M2);
  insertCone(g,c2);
  isPure(g,c2);
}

proc nmaxcones(fan f)
"USAGE:   nmaxcones(f);  f fan
RETURN:  int, the number of maximal cones in f
EXAMPLE: example nmaxcones; shows an example
"
{
  return (nmaxconesInternal(f));
}
example
{
  fan f=emptyFan(3);
  nmaxcones(f);
  intmat M1[3][3]=
    1,0,0,
    0,1,0,
    0,0,1;
  cone c1=coneViaPoints(M1);
  insertCone(f,c1);
  nmaxcones(f);
  intmat M2[2][3]=
    1,0,0,
    0,-1,0;
  cone c2=coneViaPoints(M2);
  insertCone(f,c2);
  nmaxcones(f);
}

proc ncones(fan f)
"USAGE:   ncones(f);  f fan
RETURN:  int, the number of cones in f
EXAMPLE: example ncones; shows an example
"
{
  return (nconesInternal(f));
}
example
{
  fan f=emptyFan(3);
  ncones(f);
  intmat M1[3][3]=
    1,0,0,
    0,1,0,
    0,0,1;
  cone c1=coneViaPoints(M1);
  insertCone(f,c1);
  ncones(f);
  intmat M2[2][3]=
    1,0,0,
    0,-1,0;
  cone c2=coneViaPoints(M2);
  insertCone(f,c2);
  ncones(f);
}

proc numberOfConesOfDimension(fan f, int d, list #)
"USAGE:   numberOfConesOfDimension(f,d[,m]);  f fan, d int, m int
ASSUME:  d is between 0 and ambientDimension(f)
RETURN:  cone, returns in the fan f the number of cones in dimension d
         if m!=0, it will only count maximal cones
EXAMPLE: example numberOfConesOfDimension; shows an example
"
{
  if (size(#)>0)
  {
    return (numberOfConesOfDimensionInternal(f,d,#[1]));
  }
  return (numberOfConesOfDimensionInternal(f,d));
}
example
{
  "EXAMPLE:"; echo = 2;
  fan f=emptyFan(3);
  ncones(f);
  intmat M[3][3]=
    1,0,0,
    0,1,0,
    0,0,1;
  cone c=coneViaPoints(M);
  insertCone(f,c);
  numberOfConesOfDimension(f,0,0);
  numberOfConesOfDimension(f,0,1);
  numberOfConesOfDimension(f,1,0);
  numberOfConesOfDimension(f,0,1);
  numberOfConesOfDimension(f,2,0);
  numberOfConesOfDimension(f,2,1);
  numberOfConesOfDimension(f,3,0);
  numberOfConesOfDimension(f,3,1);
}

proc removeCone(fan f, cone c, list #)
"USAGE:   removeCone(f,c[,b]);  f fan, c cone, b int
ASSUME:  containsInCollection(f,c)=1
RETURN:  none, removes the cone c from f
         if b=0, skips the check whether c is contained in f
EXAMPLE: example removeCone; shows an example
"
{
  if (size(#)==1)
  {
    return (removeConeInternal(f,c,#[1]));
  }
  return (removeConeInternal(f,c));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[2][2]=1,0,0,1;
  intmat N[2][2]=1,0,1,-1;
  cone c=coneViaPoints(M);
  cone d=coneViaPoints(N);
  fan f=emptyFan(2);
  insertCone(f,c);
  insertCone(f,d);
  f;
  removeCone(f,c);
  f;
}



/////
// polytope related functions
/////

proc dualPolytope(polytope p)
"USAGE:   dualPolytope(p);  p polytope
RETURN:  polytope, the dual of p
EXAMPLE: example dualPolytope; shows an example
"
{
  return (dualPolytopeInternal(p));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[4][2]=
    0,0,
    1,0,
    0,1,
    1,1;
  polytope p=polytopeViaPoints(M);
  dualPolytope(p);
}


proc newtonPolytope(poly f)
"USAGE:   newtonPolytope(f);  f poly
RETURN:  polytope, the convex hull of all exponent vectors of f
EXAMPLE: example newtonPolytope; shows an example
"
{
  return (newtonPolytopeInternal(f));
}
example
{
  "EXAMPLE:"; echo = 2;
  ring r;
  poly f=x+y+z;
  polytope p=newtonPolytope(f);
  p;
}

proc polytopeViaPoints(def V, list #)
"USAGE: polytopeViaPoints(V [, flags]);  intmat V, int flags
RETURN: polytope which is the intersection of the cone generated by the row vectors
of V with the hyperplane, in which the first coordinate equals 1;
flags may be 0 or 1,@*
if flags is 1, then program assumes that each row vector of M generates a ray in the cone,
if flags is 0, then program computes that information itself
EXAMPLE: example polytopeViaPoints; shows an example
"
{
  if (size(#)>0)
  {
    return (polytopeViaPointsInternal(V,#[1]));
  }
  return (polytopeViaPointsInternal(V));
}
example
{
  "EXAMPLE:"; echo = 2;
  // This is a polytope in R^2 generated by (0,0), (1,0), (0,1), (0,0);
  intmat V[4][3]=
  1,0,0,
  1,1,0,
  1,0,1,
  1,1,1;
  polytope p1=polytopeViaPoints(V);
  p1;
  // This is a polytope in R^2 generated by (1/2,2/3), (3/4,4/5), (5/6,6/7):
  intmat V[3][3]=
  6,3,4,
  20,15,16,
  42,35,36;
  polytope p2=polytopeViaPoints(V);
  p2;
  // This polytope is the positive orthant in R^2:
  // (0,1,0) and (0,0,1) imply that the polytope is unbounded in that direction
  intmat V[3][3]=
  1,0,0,
  0,1,0,
  0,0,1;
  polytope p3=polytopeViaPoints(V);
  p3;
}

proc polytopeViaInequalities(def EV, list #)
"USAGE: polytopeViaInequalities(EV [, E [, flags]]);  intmat EV,E, int flags
RETURN: polytope consisting of all points x, such that IE*x >= 0 in each component
and (if stated) E*x = 0;
flags may range between 0,..,3 defining an upper and lower bit
(0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
if higher bit is 1, then program assumes each inequality yields a facet,
if lower bit is 1, then program assumes the kernel of E is the span of the cone,
if either bit is 0, then program computes the information itself.
EXAMPLE: example polytopeViaPoints; shows an example
"
{
  if (size(#)==2)
  {
    return (polytopeViaInequalitiesInternal(EV,#[1],#[2]));
  }
  if (size(#)==1)
  {
    return (polytopeViaInequalitiesInternal(EV,#[1]));
  }
  return (polytopeViaInequalitiesInternal(EV));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat IE[2][3]=
  1,0,0,
  0,1,0;
  intmat E[1][3]=
  0,0,1;
  polytope p=polytopeViaInequalities(IE,E);
  p;
}

proc vertices(polytope p)
"USAGE:   vertices(p);  p polytope
RETURN:  bigintmat, the vertices of p modulo its lineality space
EXAMPLE: example vertices; shows an example
"
{
  return (verticesInternal(p));
}
example
{
  "EXAMPLE:"; echo = 2;
  intmat M[4][3]=
    1,0,0,
    1,2,0,
    1,0,2,
    1,2,2,
    1,1,1;
  polytope p=polytopeViaPoints(M);
  vertices(p);
}

proc onesVector(int n)
"USAGE:   onesVector(n);  n int
RETURN:  intvec, intvec of length n with all entries 1
EXAMPLE: example onesVector; shows an example
"
{
  return (onesVectorInternal(n));
}
example
{
  "EXAMPLE:"; echo = 2;
  intvec w = onesVector(3);
  w;
}

static proc mod_init()
{
  intvec save=option(get);
  option(noredefine);
  LIB "customstd.lib";
  LIB "gfanlib.so";
  option(set,save);
}
